import cv2
import torch
import numpy as np
import kornia as K
import kornia.feature as KF

def Get3DPointsOnPlane(pixelsmatch, Plane1, Plane2, fx, fy, cx, cy):
    Points = []
    for i in pixelsmatch:
        x1 = i[0]
        y1 = i[1]
        X1 = (x1-cx) / fx
        Y1 = (y1-cy) / fy
        scale1 = (-Plane1[3]) / (Plane1[0]*X1 + Plane1[1]*Y1 + Plane1[2])
        X1 = X1 * scale1
        Y1 = Y1 * scale1
        Z1 = scale1
        
        x2 = i[2]
        y2 = i[3]
        X2 = (x2-cx) / fx
        Y2 = (y2-cy) / fy
        scale2 = (-Plane2[3]) / (Plane2[0]*X2 + Plane2[1]*Y2 + Plane2[2])
        X2 = X2 * scale2
        Y2 = Y2 * scale2
        Z2 = scale2
        Points.append([X1, Y1, Z1, X2, Y2, Z2])
    return Points

def PixelMatch(pixels1, H):
    pixelsmatch = []
    for i in pixels1:
        x = i[0]
        y = i[1]
        P = np.array([[x],
                      [y],
                      [1.]], dtype=np.float32)
        P = np.matmul(H, P)
        P = P / P[2][0]
        if P[0][0] > 0 and P[0][0] < 639 and P[1][0] > 0 and P[1][0] < 479:
            pixelsmatch.append([x, y, P[0][0], P[1][0]])
        else:
            continue
    return pixelsmatch

def get_polygon_pixels(vertices, scale=1):
    # 获取四边形顶点的坐标
    p1, p2, p3, p4 = vertices[0], vertices[1], vertices[2], vertices[3]
    
    # 确定四边形的最小和最大边界
    x_min = int(min(p1[0], p2[0], p3[0], p4[0]))
    x_max = int(max(p1[0], p2[0], p3[0], p4[0]))
    y_min = int(min(p1[1], p2[1], p3[1], p4[1]))
    y_max = int(max(p1[1], p2[1], p3[1], p4[1]))

    # 创建用于存储所有像素坐标的列表
    pixel_coords = []

    # 遍历四边形内的所有像素点
    for y in range(y_min, y_max + 1, scale):
        for x in range(x_min, x_max + 1, scale):
            if is_point_inside_polygon(x, y, vertices):
                pixel_coords.append((x, y))

    return pixel_coords

def is_point_inside_polygon(x, y, vertices):
    # 判断点是否在四边形内部
    p1, p2, p3, p4 = vertices
    
    # 根据点是否在四条边的同一侧来判断点是否在四边形内部
    return (
        is_on_same_side(x, y, p1, p2, p3) 
        and is_on_same_side(x, y, p2, p3, p4)
        and is_on_same_side(x, y, p3, p4, p1)
        and is_on_same_side(x, y, p4, p1, p2)
    )

def is_on_same_side(x, y, p1, p2, p):
    # 检查点p是否在p1p2直线的同一侧
    return (y - p1[1]) * (p2[0] - p1[0]) - (x - p1[0]) * (p2[1] - p1[1]) >= 0

def load_torch_image(fname):
    img = K.image_to_tensor(cv2.imread(fname), False).float() /255.
    img = K.color.bgr_to_rgb(img)
    return img

def LoFTR(img1path, img2path, matcher):
    img1 = load_torch_image(img1path)
    img2 = load_torch_image(img2path)
    # matcher = KF.LoFTR(pretrained='indoor')
    input_dict = {"image0": K.color.rgb_to_grayscale(img1), # LofTR 只在灰度图上作用
              "image1": K.color.rgb_to_grayscale(img2)}
    with torch.inference_mode():
        correspondences = matcher(input_dict)
    # for k,v in correspondences.items():
    #     print (k)
    
    # 现在让我们用现代RANSAC清理对应关系，并估计两幅图像之间的基本矩阵
    mkpts0 = correspondences['keypoints0'].cpu().numpy()
    mkpts1 = correspondences['keypoints1'].cpu().numpy()
    confidence = correspondences["confidence"].cpu().numpy()
    kp0 = []
    kp1 = []
    for i in range(len(confidence)):
        if confidence[i] > 0.9:
            kp0.append([mkpts0[i][0], mkpts0[i][1]])
            kp1.append([mkpts1[i][0], mkpts1[i][1]])
    H, mask = cv2.findHomography(np.array(kp0), np.array(kp1), cv2.RANSAC)
    # img1 = cv2.imread(img1path)   # 特征点可视化
    # img2 = cv2.imread(img2path)
    # kp0 = []
    # num = 0
    # for i in mkpts0:
    #     if confidence[num] > 0.95:
    #         kp0.append(cv2.KeyPoint(i[0], i[1], 1))
    #         num += 1
    #     else:
    #         num += 1
    #         continue
        
    # kp1 = []
    # num = 0
    # for i in mkpts1:
    #     if confidence[num] > 0.95:
    #         kp1.append(cv2.KeyPoint(i[0], i[1], 1))
    #         num += 1
    #     else:
    #         num += 1
    #         continue
    # matches = [cv2.DMatch(i, i, 0) for i in range(len(kp1))]
    # output_img = cv2.drawMatches(img1, kp0, img2, kp1, matches, None, flags=cv2.DrawMatchesFlags_NOT_DRAW_SINGLE_POINTS)
    # cv2.imshow('Matches', output_img)
    # cv2.waitKey(0)
    # cv2.destroyAllWindows()
    return H

if __name__ == "__main__":
    root = "data\\img\\"
    loftr = KF.LoFTR(pretrained='indoor')     # 检测器
    fx = 518.9676  # 焦距x（单位像素）
    fy = 518.8752  # 焦距y（单位像素）
    cx = 320.5550  # 光心x
    cy = 237.8842  # 光心y

    Planes = [
        [[0.0484219,-0.110808,0.992661,-1.52702]],
        [[0.043905,-0.252766,0.966531,-1.51663], [0.0014181,-0.967988,-0.250994,0.80797]],
        [[-0.333008,0.223288,-0.916105,1.52755], [0.00146407,-0.970998,-0.239082,0.813396]],
        [[-0.326322,0.0929639,-0.940676,1.5439]],
        [[0.60006,-0.0934954,0.794473,-1.50684], [0.801315,0.0653384,-0.594664,1.74731]],
        [[0.588816,-0.207283,0.781236,-1.51145], [-0.000827108,-0.966356,-0.257206,0.815533]],
        [[0.56345,0.202567,-0.800931,1.64436], [-0.00616038,-0.96861,-0.248509,0.807424]],
        [[0.557206,0.0969788,-0.824692,1.65917]],
        [[-0.380391,-0.107655,0.918539,-1.61231]],
        [[0.376725,0.21868,-0.900143,1.60121], [-0.00709721,-0.969891,-0.243435,0.802681]],
        [[-0.023787,-0.240789,0.970286,-1.52368], [0.00247104,-0.969979,-0.243176,0.807225]],
        [[0.0231583,-0.0936301,0.995338,-1.53132]],
        [[0.322698,-0.106838,0.940453,-1.33757], [0.955947,0.0288489,-0.292119,0.917756]],
        [[0.463623,-0.101612,0.880187,-1.50401], [-0.43426,0.0773516,-0.89746,0.861459]],
        [[-0.646189,0.073382,-0.759642,0.804897]],
        [[-0.598278,-0.0728096,0.797974,-1.25339], [-0.795534,0.0544544,-0.603457,0.926239]],
        [[0.233043,0.0951887,-0.967796,1.46986]],
        [[-0.0470884,-0.0938375,0.994473,-1.46876]],
        [[0.0533073,0.233582,-0.970875,1.45758], [0.0108956,-0.973525,-0.228321,0.786176]],
        [[0.185516,-0.221886,0.957262,-1.46427], [0.00476823,-0.973476,-0.228741,0.783674]],
        [[0.182763,-0.0832199,0.979629,-1.47326]],
        [[0.444254,-0.091215,0.891245,-1.48156]],
        [[-0.432999,0.206642,-0.877389,1.46182], [0.000918822,-0.970566,-0.240835,0.795549]],
        [[0.636597,-0.172438,0.751671,-1.52481], [0.00207265,-0.970013,-0.243043,0.804725]],
        [[0.651899,-0.0704308,0.755028,-1.51111], [0.781163,0.0742987,-0.61989,1.40061]],
        [[0.583501,0.105684,-0.805206,1.37325], [0.830172,-0.0334325,0.556504,-1.53324]],
        [[-0.584231,-0.220578,0.781037,-1.36161], [0.00127183,-0.963314,-0.268375,0.813566]],
        [[-0.353049,-0.264881,0.897326,-1.45194], [0.00571289,-0.965345,-0.260915,0.8135]],
        [[0.0137587,0.260435,-0.965393,1.39747], [0.0107914,-0.965191,-0.261324,0.807777]],
        [[0.0103334,0.135745,-0.99069,1.41021]],
        [[-0.0283468,0.258187,-0.965679,1.36876], [0.00995448,-0.966891,-0.254996,0.807447]],
        [[-0.356525,0.0984126,-0.929088,1.3481]],
        [[0.362053,-0.246016,0.899107,-1.35153], [0.0118362,-0.958614,-0.284464,0.802286]],
        [[0.603143,-0.227364,0.764542,-1.38315], [0.00574378,-0.957742,-0.287572,0.804347]],
        [[-0.617269,0.0688136,-0.783737,1.37776], [0.804762,0.0625797,-0.59029,1.73981]],
        [[-0.764024,0.0740906,-0.64092,1.2948], [0.647694,0.0915017,-0.756386,1.61844]],
        [[0.751893,-0.165256,0.638238,-1.30527], [-0.00192571,-0.964921,-0.262532,0.811925]],
        [[0.346026,0.231589,-0.909193,1.54904], [0.00141238,-0.970753,-0.240076,0.810213]]
             ]
    matchers = [
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [1,1],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [1,0],
        [0,1],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [1,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [0,0],
        [1,1],
        [0,0],
        [1,1],
               ]
    Vertices = [
        [[(2, 2), (600, 2), (600, 450), (2, 436)]],
        [[(2, 2), (600, 2), (600, 369), (2, 357)], [(2, 358), (600, 370), (600, 476), (2, 476)]],
        [[(9, 2), (605, 2), (605, 403), (48, 313)], [(48, 314), (605, 404), (605, 476), (5, 476)]],
        [[(19, 2), (300, 2), (300, 430), (42, 385)]],
        [[(207, 2), (407, 2), (407, 427), (217, 367)], [(2, 2), (177, 2), (189, 372), (2, 438)]],
        [[(205, 2), (405, 2), (405, 345), (219, 289)], [(219, 290), (559, 391), (514, 476), (2, 373)]],
        [[(2, 2), (385, 2), (379, 292), (2, 402)], [(2, 403), (379, 293), (500, 476), (2, 476)]],
        [[(2, 2), (383, 2), (380, 367), (2, 467)]],
        [[(2, 2), (280, 2), (281, 413), (2, 459)]],
        [[(2, 2), (278, 2), (292, 350), (2, 403)], [(2, 404), (528, 306), (584, 476), (2, 476)]],
        [[(2, 2), (526, 2), (496, 373), (2, 377)], [(2, 378), (515, 373), (592, 476), (2, 476)]],
        [[(2, 2), (539, 2), (523, 457), (2, 453)]],
        [[(144, 2), (600, 2), (600, 476), (156, 376)], [(2, 2), (143, 2), (158, 430), (2, 460)]],
        [[(282, 2), (600, 2), (627, 464), (285, 409)], [(2, 2), (137, 2), (150, 456), (2, 440)]],
        [[(148, 2), (332, 2), (329, 446), (147, 436)]],
        [[(2, 2), (323, 2), (314, 429), (2, 430)], [(324, 2), (543, 2), (523, 465), (315, 429)]],
        [[(2, 2), (420, 2), (420, 423), (2, 466)]],
        [[(2, 2), (500, 2), (500, 458), (2, 465)]],
        [[(2, 2), (500, 2), (500, 376), (2, 385)], [(2, 386), (595, 375), (595, 476), (2, 476)]],
        [[(2, 2), (500, 2), (500, 389), (2, 344)], [(2, 345), (630, 404), (630, 476), (2, 476)]],
        [[(2, 2), (500, 2), (500, 472), (2, 424)]],
        [[(143, 2), (620, 2), (620, 475), (148, 392)]],
        [[(132, 2), (500, 2), (500, 392), (149, 315)], [(149, 316), (636, 423), (636, 476), (2, 387)]],
        [[(296, 2), (600, 2), (600, 405), (293, 306)], [(293, 307), (600, 406), (559, 476), (2, 423)]],
        [[(299, 2), (600, 2), (600, 462), (293, 365)], [(2, 2), (298, 2), (292, 383), (20, 473)]],
        [[(2, 2), (456, 2), (437, 384), (2, 451)], [(457, 2), (600, 2), (620, 462), (438, 384)]],
        [[(2, 2), (460, 2), (435, 301), (2, 429)], [(2, 430), (435, 302), (629, 383), (2, 476)]],
        [[(2, 2), (612, 2), (565, 313), (2, 407)], [(2, 408), (565, 314), (605, 477), (2, 476)]],
        [[(2, 2), (600, 2), (600, 376), (2, 376)], [(2, 377), (630, 376), (630, 476), (2, 476)]],
        [[(2, 2), (600, 2), (600, 463), (2, 462)]],
        [[(2, 2), (600, 2), (600, 390), (2, 378)], [(2, 379), (600, 391), (600, 476), (2, 476)]],
        [[(2, 2), (600, 2), (600, 460), (2, 350)]],
        [[(2, 2), (600, 2), (600, 409), (2, 290)], [(2, 291), (600, 410), (600, 476), (2, 460)]],
        [[(170, 2), (600, 2), (600, 406), (188, 272)], [(188, 273), (600, 407), (600, 476), (9, 337)]],
        [[(179, 2), (600, 2), (600, 450), (185, 384)], [(2, 2), (178, 2), (185, 383), (2, 452)]],
        [[(303, 2), (600, 2), (600, 440), (303, 288)], [(2, 2), (302, 2), (301, 377), (2, 470)]],
        [[(300, 2), (590, 2), (541, 385), (299, 286)], [(2, 389), (297, 299), (459, 369), (2, 476)]],
        [[(2, 2), (524, 2), (496, 323), (2, 404)], [(2, 405), (496, 324), (596, 381), (2, 470)]],
              ]
    
    for i in range(26, 29, 1):
        img1_path = root + str(i) + ".jpg"
        img2_path = root + str(i+1) + ".jpg"
        H = LoFTR(img1_path, img2_path, loftr)
        # img1 = cv2.imread(img1_path)        # 保存图像
        # img1Reg = cv2.warpPerspective(img1, H, (640, 480))
        # cv2.imwrite(root + str(i+1) + "_reg.jpg", img1Reg)
        # print(root + str(i+1) + "_reg.jpg")
        matchID1 = matchers[i-1][0]
        matchID2 = matchers[i-1][1]
        plane1 = Planes[i-1][matchID1]
        plane2 = Planes[i][matchID2]
        vertice1 = Vertices[i-1][matchID1]
        pixels1 = get_polygon_pixels(vertice1)
        pixelsmatch = PixelMatch(pixels1, H)
        pointsmatch = Get3DPointsOnPlane(pixelsmatch, plane1, plane2, fx, fy, cx, cy)
        print("Points" + str(i+1) + "-" + str(i) + ".txt")
        with open(root + "Points" + str(i+1) + "-" + str(i) + ".txt", "w") as f:
            for i in range(0, len(pointsmatch), int(len(pointsmatch)/50)):
                data = str(pointsmatch[i][0]) + "," + str(pointsmatch[i][1]) + "," + str(pointsmatch[i][2]) + "," + str(pointsmatch[i][3]) + "," + str(pointsmatch[i][4]) + "," + str(pointsmatch[i][5]) + "\n"
                f.write(data)